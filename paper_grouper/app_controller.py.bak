from __future__ import annotations

from pathlib import Path
from typing import Any, Dict, List, Sequence

from paper_grouper.core.cluster_postprocess import finalize_clustering
from paper_grouper.core.community_detector import detect_communities_louvain
from paper_grouper.core.data import ArticleRecord, ClusteringResult, EmbeddingResult
from paper_grouper.core.embedder import embed_articles_light
from paper_grouper.core.graph_builder import build_knn_graph
from paper_grouper.core.metadata_extractor import batch_extract
from paper_grouper.io.file_scanner import list_pdfs
from paper_grouper.io.graph_visualizer import render_graph_png
from paper_grouper.io.output_writer import prepare_output_dir, write_clustered_files

# -----------------------
# Cancelamento simples
# -----------------------
_CANCEL = False


def request_cancel() -> None:
    global _CANCEL
    _CANCEL = True


def _clear_cancel() -> None:
    global _CANCEL
    _CANCEL = False


def _check_cancel_or_raise() -> None:
    if _CANCEL:
        raise KeyboardInterrupt()


# -----------------------
# Wrapper de embedding
# -----------------------
def _embed(articles: List[ArticleRecord], *, use_light: bool) -> EmbeddingResult:
    # Hoje só existe o "light" exposto; mantemos a flag para compatibilidade
    return embed_articles_light(articles)


# -----------------------
# Execução manual (OK)
# -----------------------
def run_manual(
    input_dir: str,
    output_dir: str | None,
    k: int,
    resolution: float,
    min_cluster_size: int,
    *,
    rename: bool = True,
    use_light: bool = True,
) -> Dict[str, Any]:
    """
    Executa o pipeline manual: scan -> metadados -> embed -> kNN -> Louvain -> pós-processo.
    Retorna dict com chaves estáveis para a UI.
    """
    _clear_cancel()
    try:
        # 1) PDFs
        _check_cancel_or_raise()
        pdf_paths = list_pdfs(input_dir)
        if not pdf_paths:
            raise FileNotFoundError("Nenhum PDF encontrado na pasta de entrada.")

        # 2) Metadados (normaliza para dict id->ArticleRecord)
        _check_cancel_or_raise()
        arts_or_dict = batch_extract(pdf_paths)
        articles_by_id: Dict[str, ArticleRecord] = {
            a.id: a
            for a in (
                arts_or_dict.values()
                if hasattr(arts_or_dict, "values")
                else arts_or_dict
            )
        }
        articles_list = list(articles_by_id.values())

        # 3) Embeddings
        _check_cancel_or_raise()
        emb: EmbeddingResult = _embed(articles_list, use_light=use_light)

        # 4) Grafo kNN (garante 1 <= k <= n-1)
        _check_cancel_or_raise()
        n = max(0, len(articles_list))
        k_eff = max(1, min(k, max(1, n - 1))) if n > 1 else 1
        G = build_knn_graph(emb, k=k_eff)

        # 5) Comunidades (Louvain)
        _check_cancel_or_raise()
        partition = detect_communities_louvain(G, resolution=resolution)

        # 6) Pós-processamento (usa pesos padrão alpha,beta,gamma)
        _check_cancel_or_raise()
        clustering_result: ClusteringResult = finalize_clustering(
            partition, G, articles_list, min_cluster_size, 0.5, 0.3, 0.2
        )

        # 7) Artefatos
        _check_cancel_or_raise()
        output_root = prepare_output_dir(input_dir, output_dir)
        graph_png = render_graph_png(G, clustering_result, output_root)

        if rename:
            write_clustered_files(
                output_root, clustering_result, articles_by_id, rename_with_title=rename
            )

        summary = getattr(clustering_result, "summary", lambda: None)() or {
            "n_clusters": len(getattr(clustering_result, "clusters", {}))
        }

        return {
            "status": "ok",
            "articles": articles_by_id,
            "clustering": clustering_result,
            "graph_png": str(graph_png) if isinstance(graph_png, (str, Path)) else None,
            "output_root": str(output_root),
            "summary": summary,
        }

    except KeyboardInterrupt:
        _clear_cancel()
        return {"status": "cancelled"}
    except Exception as exc:  # noqa: BLE001
        return {"error": f"{type(exc).__name__}: {exc}"}
    finally:
        _clear_cancel()


# -----------------------
# Autotune (stub mínimo)
# -----------------------
def run_autotune(
    input_dir: str,
    output_dir: str | None,
    k_values: Sequence[int],
    resolution_values: Sequence[float],
    min_cluster_values: Sequence[int],
    *,
    rename: bool = True,
    use_light: bool = True,
    max_workers: int = 0,
) -> Dict[str, Any]:
    """
    Stub temporário: mantemos a assinatura para não quebrar a UI.
    Implementação completa será feita em issue dedicada.
    """
    return {
        "status": None,
        "error": "Autotune temporariamente desabilitado (stub).",
        "graph_png": None,
        "summary": None,
        "best_params": None,
    }


__all__ = ["run_manual", "run_autotune", "request_cancel"]
